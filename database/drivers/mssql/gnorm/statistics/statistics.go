// Code generated by gnorm, DO NOT EDIT!

package statistics

import (
	"database/sql"
	"gnorm.org/gnorm/database/drivers/mssql/gnorm"
	"log"
)

// Row represents a row from 'STATISTICS'.
type Row struct {
	TableName          string         // TableName
	TableId            int64          // TableId
	ObjectId           int64          // object_id
	Name               string // name
	IndexId            int            // index_id
	TypeNum            int            // type_num
	TypeDesc           string         // type_desc
	IsUnique           bool           // is_unique
	DataSpaceId        int            // data_space_id
	IgnoreDupKey       bool           // ignore_dup_key
	IsPrimaryKey       bool           // is_primary_key
	IsUniqueConstraint bool           // is_unique_constraint
	FillFactor         int            // fill_factor
	IsPadded           bool           // is_padded
	IsDisabled         bool           // is_disabled
	IsHypothetical     bool           // is_hypothetical
	AllowRowLocks      bool           // allow_row_locks
	AllowPageLocks     bool           // allow_page_locks
	HasFilter          bool           // has_filter
	FilterDefinition   sql.NullString // filter_definition
	CompressionDelay   sql.NullString // compression_delay
}

type RowColumns struct {
	TableName  string
	IndexName  string
	IndexId    int64
	ColumnId   int64
	ColumnName string
}

// Query retrieves rows from 'STATISTICS' as a slice of Row.
func Query(db gnorm.DB, table string) ([]*Row, error) {
	const sqlstr = `

    SELECT 
		   t.name as TableName,
		   t.object_id as TableId,

		   ind.object_id,
		   ind.name,
		   ind.index_id ,
		   ind.type ,
		   ind.type_desc ,
		   ind.is_unique ,
		   ind.data_space_id ,
		   ind.ignore_dup_key ,
		   ind.is_primary_key ,
		   ind.is_unique_constraint ,
		   ind.fill_factor ,
		   ind.is_padded ,
		   ind.is_disabled ,
		   ind.is_hypothetical ,
		   ind.allow_row_locks ,
		   ind.allow_page_locks,
		   ind.has_filter,
		   ind.filter_definition,
		   ind.compression_delay

      FROM sys.indexes ind

 LEFT JOIN sys.tables t 
        ON ind.object_id = t.object_id 

	 WHERE t.type = 'U'
           AND ind.name IS NOT NULL
		   AND t.name = @table
	;

`
	log.Println("querying indices ", sqlstr)
	log.Println("from table ", table)

	var vals []*Row
	q, err := db.Query(sqlstr,
		sql.Named("table", table),
	)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}

		err = q.Scan(
			&r.TableName,
			&r.TableId,
			&r.ObjectId,
			&r.Name,
			&r.IndexId,
			&r.TypeNum,
			&r.TypeDesc,
			&r.IsUnique,
			&r.DataSpaceId,
			&r.IgnoreDupKey,
			&r.IsPrimaryKey,
			&r.IsUniqueConstraint,
			&r.FillFactor,
			&r.IsPadded,
			&r.IsDisabled,
			&r.IsHypothetical,
			&r.AllowRowLocks,
			&r.AllowPageLocks,
			&r.HasFilter,
			&r.FilterDefinition,
			&r.CompressionDelay,
		)

		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}

// Query retrieves rows from 'STATISTICS' as a slice of Row.
func QueryIndex(db gnorm.DB, index string) ([]*RowColumns, error) {

	const sqlstr = `

    SELECT 
           t.name as TableName,
           ind.name as IndexName,
           ind.index_id as IndexId,      
           ic.index_column_id as ColumnId, 
           col.name as ColumnName
		
      FROM sys.indexes ind 

INNER JOIN sys.index_columns ic 
        ON ind.object_id = ic.object_id
       AND ind.index_id = ic.index_id 

INNER JOIN sys.columns col 
        ON ic.object_id = col.object_id 
       AND ic.column_id = col.column_id 

INNER JOIN sys.tables t 
        ON ind.object_id = t.object_id 

     WHERE ind.name = @index

  ORDER BY t.name, 
           ind.name, 
           ind.index_id, 
	       ic.index_column_id

;
`
	log.Println("querying index info ", sqlstr)
	log.Println("from index ", index)

	var vals []*RowColumns
	q, err := db.Query(sqlstr,
		sql.Named("index", index),
	)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := RowColumns{}

		err = q.Scan(
			&r.TableName,
			&r.IndexName,
			&r.IndexId,
			&r.ColumnId,
			&r.ColumnName,
		)

		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}
