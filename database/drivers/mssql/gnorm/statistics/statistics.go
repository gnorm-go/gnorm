// Code generated by gnorm, DO NOT EDIT!

package statistics

import (
	"gnorm.org/gnorm/database/drivers/mssql/gnorm"
	"log"
	"strings"
)

// Row represents a row from 'STATISTICS'.
type Row struct {
	TableName  string // TableName
	TableId    int64  // TableId
	Unique     bool   // NON_UNIQUE
	IndexName  string // INDEX_NAME
	SeqInIndex int64  // SEQ_IN_INDEX
	Origin     string // SEQ_IN_INDEX
	Partial    int64  // SEQ_IN_INDEX
}

type RowColumns struct {
	SeqNo int
	Cid   int
	Name  string
	Desc  string
	Coll  string
	Key   int
}

// Query retrieves rows from 'STATISTICS' as a slice of Row.
func Query(db gnorm.DB, table string) ([]*Row, error) {
	const sqlstr = `

    SELECT 
		   t.name as TableName,
		   t.object_id as TableId,

		   ind.object_id,
		   ind.name,
		   ind.index_id ,
		   ind.type ,
		   ind.type_desc ,
		   ind.is_unique ,
		   ind.data_space_id ,
		   ind.ignore_dup_key ,
		   ind.is_primary_key ,
		   ind.is_unique_constraint ,
		   ind.fill_factor ,
		   ind.is_padded ,
		   ind.is_disabled ,
		   ind.is_hypothetical ,
		   ind.allow_row_locks ,
		   ind.allow_page_locks,
		   ind.has_filter,
		   ind.filter_definition,
		   ind.compression_delay


      FROM sys.indexes ind

 LEFT JOIN sys.tables t 
        ON ind.object_id = t.object_id 

	 WHERE t.type = 'U'
		   AND t.name = 'Contact'
	;

`
	sql := strings.Replace(sqlstr, "XXXTABLEXXX", table, -1)
	log.Println("querying indices ", sql)
	log.Println("from table ", table)

	var vals []*Row
	q, err := db.Query(sql)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}

		err = q.Scan(
			&r.SeqInIndex,
			&r.IndexName,
			&r.Unique,
			&r.Origin,
			&r.Partial,
		)

		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}

// Query retrieves rows from 'STATISTICS' as a slice of Row.
func QueryIndex(db gnorm.DB, index string) ([]*RowColumns, error) {

	const sqlstr = `

    SELECT 
           t.name as TableName,
           ind.name as IndexName,
           ind.index_id as IndexId,      
           ic.index_column_id as ColumnId, 
           col.name as ColumnName,
           
           object_id,
           name,
           index_id,
           type,
           type_desc,
           is_unique,
           data_space_id, 
           ignore_dup_key,
           is_primary_key,
           is_unique_constraint, 
           fill_factor, 
           is_padded,   
           is_disabled,  
           is_hypothetical,  
           allow_row_locks, 
           allow_page_locks,
           has_filter,
           filter_definition,
           compression_delay,
           object_id,
           index_id,
           index_column_id,
           column_id,
           key_ordinal, 
           partition_ordinal, 
           is_descending_key,  
           is_included_column, 
           object_id,    
           name,     
           column_id,  
           system_type_id,     
           user_type_id,   
           max_length,   
           precision,     
           scale,    
           collation_name,   
           is_nullable,      
           is_ansi_padded,   
           is_rowguidcol,    
           is_identity,     
           is_computed,    
           is_filestream, 
           is_replicated, 
           is_non_sql_subscribed,   
           is_merge_published,      
           is_dts_replicated,   
           is_xml_document,    
           xml_collection_id,  
           default_object_id,  
           rule_object_id,     
           is_sparse,     
           is_column_set, 
           generated_always_type,     
           generated_always_type_desc, 
           encryption_type,     
           encryption_type_desc,
           encryption_algorithm_name, 
           column_encryption_key_id,  
           column_encryption_key_database_name,  
           is_hidden,     
           is_masked
		
      FROM sys.indexes ind 

INNER JOIN sys.index_columns ic 
        ON ind.object_id = ic.object_id
       AND ind.index_id = ic.index_id 

INNER JOIN sys.columns col 
        ON ic.object_id = col.object_id 
       AND ic.column_id = col.column_id 

INNER JOIN sys.tables t 
        ON ind.object_id = t.object_id 

     WHERE t.name = 'Groupe'
  ORDER BY t.name, 
           ind.name, 
           ind.index_id, 
	       ic.index_column_id

;
`
	sql := strings.Replace(sqlstr, "XXXINDEXXXX", index, -1)
	log.Println("querying index info ", sql)
	log.Println("from index ", index)

	var vals []*RowColumns
	q, err := db.Query(sql)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := RowColumns{}

		err = q.Scan(
			&r.SeqNo,
			&r.Cid,
			&r.Name,
			&r.Desc,
			&r.Coll,
			&r.Key,
		)

		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}
