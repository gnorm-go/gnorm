// Code generated by gnorm, DO NOT EDIT!

package columns

import (
	"database/sql"
	"log"
	"strings"

	"gnorm.org/gnorm/database/drivers/mssql/gnorm"
)

// Row represents a row from 'COLUMNS'.
type Row struct {
	ColumnName      string         // COLUMN_NAME
	OrdinalPosition int64          // ORDINAL_POSITION
	ColumnDefault   sql.NullString // COLUMN_DEFAULT
	IsNullable      bool           // IS_NULLABLE
	DataType        string         // DATA_TYPE
	ColumnType      string         // COLUMN_TYPE
	ColumnKey       int            // COLUMN_KEY
}

// Query retrieves rows from 'COLUMNS' as a slice of Row.
func Query(db gnorm.DB, schema string, table string) ([]*Row, error) {
	const sqlstr = `


SELECT TABLE_CATALOG,
       TABLE_SCHEMA,
	   TABLE_NAME,
	   COLUMN_NAME,
	   ORDINAL_POSITION,
	   COLUMN_DEFAULT,
	   IS_NULLABLE,
	   DATA_TYPE,
	   CHARACTER_MAXIMUM_LENGTH,
	   CHARACTER_SET_CATALOG,
	   NUMERIC_PRECISION,
	   NUMERIC_PRECISION_RADIX, 
	   NUMERIC_SCALE, 
	   DATETIME_PRECISION, 
	   CHARACTER_SET_CATALOG,
	   CHARACTER_SET_SCHEMA,
	   CHARACTER_SET_NAME,
	   COLLATION_CATALOG,
	   COLLATION_SCHEMA,
	   COLLATION_NAME,
	   DOMAIN_CATALOG,
	   DOMAIN_SCHEMA,
	   DOMAIN_NAME
       
  FROM INFORMATION_SCHEMA.COLUMNS
  WHERE TABLE_SCHEMA = ?
       AND TABLE_NAME = ?
  ;
`

	execsql := strings.Replace(sqlstr, "XXXTABLEXXX", table, -1)
	log.Println("querying columns ", execsql)
	log.Println("from table ", table)

	var vals []*Row
	q, err := db.Query(execsql, schema, table)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}

		err = q.Scan(&r.OrdinalPosition, &r.ColumnName, &r.DataType, &r.IsNullable, &r.ColumnDefault, &r.ColumnKey)
		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}
