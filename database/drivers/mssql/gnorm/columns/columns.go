// Code generated by gnorm, DO NOT EDIT!

package columns

import (
	"database/sql"
	"gnorm.org/gnorm/database/drivers/mssql/gnorm"
	"log"
)

// Row represents a row from 'COLUMNS'.
type Row struct {
	TableCatalog           string         // TABLE_CATALOG
	TableSchema            string         // TABLE_SCHEMA
	TableName              string         // TABLE_NAME
	ColumnName             string         // COLUMN_NAME
	OrdinalPosition        int            // ORDINAL_POSITION
	ColumnDefault          sql.NullString // COLUMN_DEFAULT
	IsNullable             string         // IS_NULLABLE
	DataType               string         // DATA_TYPE
	NumericPrecision       sql.NullInt64  // NUMERIC_PRECISION
	NumericPrecisionRadix  sql.NullInt64  // NUMERIC_PRECISION_RADIX
	NumericScale           sql.NullInt64  // NUMERIC_SCALE
	DatetimePrecision      sql.NullInt64  // DATETIME_PRECISION
	CharacterMaximumLength sql.NullInt64  // CHARACTER_MAXIMUM_LENGTH
	CharacterSetCatalog    sql.NullString // CHARACTER_SET_CATALOG
	CharacterSetSchema     sql.NullString // CHARACTER_SET_SCHEMA
	CharacterSetName       sql.NullString // CHARACTER_SET_NAME
	CollationCatalog       sql.NullString // COLLATION_CATALOG
	CollationSchema        sql.NullString // COLLATION_SCHEMA
	CollationName          sql.NullString // COLLATION_NAME
	DomainCatalog          sql.NullString // DOMAIN_CATALOG
	DomainSchema           sql.NullString // DOMAIN_SCHEMA
	DomainName             sql.NullString // DOMAIN_NAME
	Pk                     bool           // PK
}

// Query retrieves rows from 'COLUMNS' as a slice of Row.
func Query(db gnorm.DB, schema string, table string) ([]*Row, error) {
	const strsql = `

SELECT c.TABLE_CATALOG,
       c.TABLE_SCHEMA,
	   c.TABLE_NAME,
	   c.COLUMN_NAME,
	   c.ORDINAL_POSITION,
	   c.COLUMN_DEFAULT,
	   c.IS_NULLABLE,
	   c.DATA_TYPE,
	   c.NUMERIC_PRECISION,
	   c.NUMERIC_PRECISION_RADIX, 
	   c.NUMERIC_SCALE, 
	   c.DATETIME_PRECISION, 
	   c.CHARACTER_MAXIMUM_LENGTH,
	   c.CHARACTER_SET_CATALOG,
	   c.CHARACTER_SET_SCHEMA,
	   c.CHARACTER_SET_NAME,
	   c.COLLATION_CATALOG,
	   c.COLLATION_SCHEMA,
	   c.COLLATION_NAME,
	   c.DOMAIN_CATALOG,
	   c.DOMAIN_SCHEMA,
	   c.DOMAIN_NAME,
CASE WHEN EXISTS 
  	    (

SELECT cu.Column_Name
 from 
    INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc, 
    INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE cu 
WHERE 
    cu.Constraint_Name = tc.Constraint_Name
    AND cu.Table_Name = tc.Table_Name
    AND tc.Constraint_Type = 'PRIMARY KEY'
    AND cu.Table_Name = c.TABLE_NAME
	AND cu.Column_Name = c.COLUMN_NAME) 
       THEN 'TRUE' 
       ELSE 'FALSE'
  END AS PK

  FROM INFORMATION_SCHEMA.COLUMNS c

  WHERE TABLE_SCHEMA = @schema
       AND TABLE_NAME = @table
  ;
`
	log.Println("querying columns ", strsql)
	log.Println("from schema ", schema)
	log.Println("from table ", table)

	var vals []*Row
	q, err := db.Query(strsql,
		sql.Named("schema", schema),
		sql.Named("table", table),
	)

	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}

		err = q.Scan(
			&r.TableCatalog,
			&r.TableSchema,
			&r.TableName,
			&r.ColumnName,
			&r.OrdinalPosition,
			&r.ColumnDefault,
			&r.IsNullable,
			&r.DataType,
			&r.NumericPrecision,
			&r.NumericPrecisionRadix,
			&r.NumericScale,
			&r.DatetimePrecision,
			&r.CharacterMaximumLength,
			&r.CharacterSetCatalog,
			&r.CharacterSetSchema,
			&r.CharacterSetName,
			&r.CollationCatalog,
			&r.CollationSchema,
			&r.CollationName,
			&r.DomainCatalog,
			&r.DomainSchema,
			&r.DomainName,
			&r.Pk,
		)
		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}


// Row represents a row from 'COLUMNS'.
type ForeignRow struct {
	PkTableQualifier string // PKTABLE_QUALIFIER
	PkTableOwner     string // PKTABLE_OWNER
	PkTableName      string // PKTABLE_NAME
	PkColumnName     string // PKCOLUMN_NAME
	FkTableQualifier string // FKTABLE_QUALIFIER
	FkTableOwner     string // FKTABLE_OWNER
	FkTableName      string // FKTABLE_NAME
	FkColumnName     string // FKCOLUMN_NAME
	KeySeq           int    // KEY_SEQ
	UpdateRule       int    // UPDATE_RULE
	DeleteRule       int    // DELETE_RULE
	FkName           string // FK_NAME
	PkName           string // PK_NAME
	Deferrability    int    // DEFERRABILITY
}

// Query retrieves rows from 'COLUMNS' as a slice of Row.
func QueryForeign(db gnorm.DB, schema string, table string) ([]*ForeignRow, error) {
	const strsql = ` EXEC sp_fkeys @fktable_name =  @table ; `
	log.Println("querying foreignkeys ", strsql)
	log.Println("from table ", table)

	var vals []*ForeignRow
	q, err := db.Query(strsql,
		sql.Named("table", table),
	)

	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := ForeignRow{}

		err = q.Scan(
			&r.PkTableQualifier,
			&r.PkTableOwner,
			&r.PkTableName,
			&r.PkColumnName,
			&r.FkTableQualifier,
			&r.FkTableOwner,
			&r.FkTableName,
			&r.FkColumnName,
			&r.KeySeq,
			&r.UpdateRule,
			&r.DeleteRule,
			&r.FkName,
			&r.PkName,
			&r.Deferrability,
		)
		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}

